// server.js
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const fs = require('fs');

const app = express();
const server = http.createServer(app);
const io = new Server(server);

app.use(express.static('public'));
app.use(express.json());

// Load sample players DB (you can replace players.json in Replit)
let playersPool = [];
try {
  playersPool = JSON.parse(fs.readFileSync('./players.json', 'utf8'));
} catch(e){
  // fallback small sample
  playersPool = [
    {name: "Luka Modric", position: "CM", basePrice: 50},
    {name: "Cristiano Ronaldo", position: "CF", basePrice: 70},
    {name: "Manuel Neuer", position: "GK", basePrice: 40},
    {name: "Virgil van Dijk", position: "CB", basePrice: 55},
    {name: "Mohamed Salah", position: "RW", basePrice: 60},
    {name: "Kylian Mbappé", position: "CF", basePrice: 80},
  ];
}

// Utility: pick random player by position that hasn't been sold in this room
function pickPlayerForPosition(roomState, pos){
  const available = playersPool.filter(p => p.position === pos && !roomState.soldPlayers.has(p.name));
  if(available.length === 0) return null;
  return available[Math.floor(Math.random()*available.length)];
}

// In-memory rooms
const rooms = {}; // roomId -> state

io.on('connection', socket => {
  console.log('conn', socket.id);

  socket.on('createRoom', ({roomId, capacity, username}, cb) => {
    if(rooms[roomId]) return cb({ok:false, msg:'Room already exists'});
    if(capacity < 3 || capacity > 6) return cb({ok:false, msg:'Capacity 3-6 only'});
    rooms[roomId] = {
      id: roomId,
      capacity,
      players: {}, // socketId -> player object
      order: [], // socketId order
      host: socket.id,
      phase: 'lobby',
      soldPlayers: new Set(),
      currentAuction: null,
    };
    socket.join(roomId);
    const player = {id: socket.id, username, balance: 1000, team: [], skipped: false};
    rooms[roomId].players[socket.id] = player;
    rooms[roomId].order.push(socket.id);
    cb({ok:true});
    io.to(roomId).emit('roomUpdate', sanitizeRoom(rooms[roomId]));
  });

  socket.on('joinRoom', ({roomId, username}, cb) => {
    const room = rooms[roomId];
    if(!room) return cb({ok:false, msg:'Room not found'});
    if(Object.keys(room.players).length >= room.capacity) return cb({ok:false, msg:'Room full'});
    socket.join(roomId);
    const player = {id: socket.id, username, balance: 1000, team: [], skipped: false};
    room.players[socket.id] = player;
    room.order.push(socket.id);
    cb({ok:true});
    io.to(roomId).emit('roomUpdate', sanitizeRoom(room));
  });

  socket.on('startGame', ({roomId}) => {
    const room = rooms[roomId];
    if(!room) return;
    if(socket.id !== room.host) return;
    if(Object.keys(room.players).length < 2) return; // at least 2
    room.phase = 'running';
    io.to(roomId).emit('roomUpdate', sanitizeRoom(room));
    startNextAuction(roomId);
  });

  socket.on('spinWheel', ({roomId}) => {
    // host triggers spin — but we auto-spin after each auction too
    const room = rooms[roomId];
    if(!room) return;
    // pick random position from pool positions (if none set, use common list)
    const positions = Array.from(new Set(playersPool.map(p=>p.position)));
    const pos = positions[Math.floor(Math.random()*positions.length)];
    io.to(roomId).emit('wheelResult', {position: pos});
  });

  socket.on('bid', ({roomId, amount}, cb) => {
    const room = rooms[roomId];
    if(!room || !room.currentAuction) return cb({ok:false, msg:'No auction'});
    const auction = room.currentAuction;
    const player = room.players[socket.id];
    if(!player) return cb({ok:false, msg:'not in room'});
    if(player.skipped) return cb({ok:false, msg:'You skipped this round'});
    if(player.team.length >= 11) return cb({ok:false, msg:'Max 11 players reached'});
    // check amount validity
    if(auction.highestBidder === null){
      // first bid can be equal to basePrice
      if(amount !== auction.basePrice && amount !== auction.basePrice + getStep(auction.basePrice)) {
        return cb({ok:false, msg:'First bid must be basePrice or basePrice+step'});
      }
    } else {
      const step = getStep(auction.currentBid);
      if(amount < auction.currentBid + step) return cb({ok:false, msg:`Bid must be at least ${auction.currentBid + step}M`});
    }
    if(amount > player.balance) return cb({ok:false, msg:'Insufficient balance'});
    // accept bid
    auction.currentBid = amount;
    auction.highestBidder = socket.id;
    // reset skipped status for this player only? no — skipping stays for those who skipped earlier
    // restart post-bid 20s timer
    if(auction.postBidTimer) clearTimeout(auction.postBidTimer);
    auction.postBidTimer = setTimeout(()=> finalizeAuction(roomId), 20*1000);
    io.to(roomId).emit('auctionUpdate', publicAuction(auction, room));
    cb({ok:true});
  });

  socket.on('skip', ({roomId}, cb) => {
    const room = rooms[roomId];
    if(!room || !room.currentAuction) return cb({ok:false});
    const auction = room.currentAuction;
    const player = room.players[socket.id];
    if(!player) return cb({ok:false});
    player.skipped = true;
    io.to(roomId).emit('chat', {msg: `${player.username} skipped.`});
    checkIfOnlyOneLeft(roomId);
    cb({ok:true});
  });

  socket.on('requestRoom', (roomId, cb) => {
    const room = rooms[roomId];
    if(!room) return cb({ok:false});
    cb({ok:true, room: sanitizeRoom(room)});
  });

  socket.on('disconnect', () => {
    // remove from any room
    for(const rId of Object.keys(rooms)){
      const room = rooms[rId];
      if(room.players[socket.id]){
        delete room.players[socket.id];
        room.order = room.order.filter(id => id !== socket.id);
        io.to(rId).emit('roomUpdate', sanitizeRoom(room));
        // if room empty, delete it
        if(Object.keys(room.players).length === 0){
          cleanupRoom(rId);
        }
      }
    }
  });
});

// Helpers

function sanitizeRoom(room){
  // return public view
  const players = Object.values(room.players).map(p => ({
    id: p.id, username: p.username, balance: p.balance, team: p.team
  }));
  return {
    id: room.id,
    capacity: room.capacity,
    players,
    phase: room.phase,
    host: room.host,
    currentAuction: room.currentAuction ? publicAuction(room.currentAuction, room) : null
  };
}

function publicAuction(auction, room){
  return {
    position: auction.position,
    player: auction.player,
    basePrice: auction.basePrice,
    currentBid: auction.currentBid,
    highestBidder: auction.highestBidder ? room.players[auction.highestBidder]?.username : null,
    biddersCount: auction.biddersCount,
    timeLeft: auction.timeLeft || 0
  };
}

function getStep(value){
  return value >= 200 ? 10 : 5;
}

function startNextAuction(roomId){
  const room = rooms[roomId];
  if(!room) return;
  // reset skips
  for(const p of Object.values(room.players)) p.skipped = false;
  // pick position randomly
  const positions = Array.from(new Set(playersPool.map(p=>p.position)));
  const pos = positions[Math.floor(Math.random()*positions.length)];
  const picked = pickPlayerForPosition(room, pos);
  if(!picked){
    io.to(roomId).emit('chat', {msg: 'No more players for position ' + pos + '. Skipping.'});
    // try again
    return setTimeout(()=> startNextAuction(roomId), 500);
  }
  // create auction object
  const auction = {
    position: pos,
    player: picked,
    basePrice: picked.basePrice,
    currentBid: picked.basePrice,
    highestBidder: null,
    biddersCount: 0,
    postBidTimer: null,
    initialTimer: null,
    timeLeft: 45, // for broadcasting convenience
  };
  room.currentAuction = auction;
  io.to(roomId).emit('auctionStart', publicAuction(auction, room));
  // initial 45s timer - broadcast ticks every second (optional)
  let ticks = 45;
  auction.initialTimer = setInterval(()=>{
    ticks--;
    auction.timeLeft = ticks;
    io.to(roomId).emit('auctionTick', {timeLeft: ticks});
    if(ticks <= 0){
      clearInterval(auction.initialTimer);
      auction.initialTimer = null;
      // if no bids at all -> everyone skipped? check
      // if highestBidder is null -> everyone skipped or no bids; treat as skipped by everyone and move on
      if(auction.highestBidder === null){
        // move on immediately
        io.to(roomId).emit('chat', {msg: 'No bids. Item skipped.'});
        room.soldPlayers.add(auction.player.name); // optional: mark as seen to avoid repeat
        room.currentAuction = null;
        setTimeout(()=> startNextAuction(roomId), 1500);
      } else {
        // There was a bid, start 20s post-bid timer to finalize
        if(auction.postBidTimer) clearTimeout(auction.postBidTimer);
        auction.postBidTimer = setTimeout(()=> finalizeAuction(roomId), 20*1000);
        io.to(roomId).emit('chat', {msg: `Bidding paused. Finalizing in 20s...`});
      }
    }
  }, 1000);
}

function finalizeAuction(roomId){
  const room = rooms[roomId];
  if(!room || !room.currentAuction) return;
  const auction = room.currentAuction;
  // if there is a highestBidder -> award
  if(auction.postBidTimer){ clearTimeout(auction.postBidTimer); auction.postBidTimer=null; }
  if(auction.initialTimer){ clearInterval(auction.initialTimer); auction.initialTimer=null; }
  if(auction.highestBidder){
    const winner = room.players[auction.highestBidder];
    const price = auction.currentBid;
    if(winner.balance >= price && winner.team.length < 11){
      winner.balance -= price;
      winner.team.push({name: auction.player.name, price});
      room.soldPlayers.add(auction.player.name);
      io.to(roomId).emit('chat', {msg: `${winner.username} won ${auction.player.name} for ${price}M`});
      io.to(roomId).emit('roomUpdate', sanitizeRoom(room));
    } else {
      io.to(roomId).emit('chat', {msg: `Could not finalize sale to ${winner ? winner.username : 'unknown'} (insufficient funds or team full).`});
    }
  } else {
    io.to(roomId).emit('chat', {msg: 'No winner this round.'});
  }
  room.currentAuction = null;
  // auto-spin next after short delay
  setTimeout(()=> startNextAuction(roomId), 1500);
}

function checkIfOnlyOneLeft(roomId){
  const room = rooms[roomId];
  if(!room || !room.currentAuction) return;
  const activePlayers = Object.values(room.players).filter(p => !p.skipped && p.team.length < 11);
  if(activePlayers.length === 1){
    // award to that player at currentBid if they can pay, else skip
    const winner = activePlayers[0];
    const auction = room.currentAuction;
    const price = auction.currentBid;
    if(winner.balance >= price){
      if(auction.initialTimer){ clearInterval(auction.initialTimer); auction.initialTimer=null; }
      if(auction.postBidTimer) clearTimeout(auction.postBidTimer);
      winner.balance -= price;
      winner.team.push({name: auction.player.name, price});
      room.soldPlayers.add(auction.player.name);
      io.to(roomId).emit('chat', {msg: `${winner.username} was the only bidder left and won ${auction.player.name} for ${price}M`});
      io.to(roomId).emit('roomUpdate', sanitizeRoom(room));
      room.currentAuction = null;
      setTimeout(()=> startNextAuction(roomId), 1500);
    } else {
      io.to(roomId).emit('chat', {msg: `${winner.username} cannot afford this player. Skipping.`});
      room.currentAuction = null;
      setTimeout(()=> startNextAuction(roomId), 1500);
    }
  }
}

function cleanupRoom(roomId){
  delete rooms[roomId];
}

const PORT = process.env.PORT || 3000;
server.listen(PORT, ()=> console.log('listening on', PORT));
